AWSTemplateFormatVersion: "2010-09-09"

Description: This template automates disaster recovery for your self managed Active Directory on AWS. It deploys a VPC and other network resources like NAT Gateway, subnets and etc. It then creates an EC2 instance and restores the systems state backup from the EBS volume specified at Stack creation.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Configuration settings for the restored domain controller EC2 instance and bastion host
        Parameters:
          - InstanceType
          - RestoredDcNameTag
          - DomainControllerAMI
          - RestoredEBSVolumeID
          - WindowsAmiId
          - KeyPair

      - Label:
          default: Network configuration 
        Parameters:
          - description
          - Subnet1AZ
          - Subnet2AZ
          - PrivateSubnet1
          - PrivateSubnet2
          - PublicSubnet1Cidr
          - PublicSubnet2Cidr

    ParameterLabels:
      InstanceType:
        default: Domain Controller instance type
      RestoredDcNameTag:
        default: Specifiy a name tag for the restored Domain Controller
      RestoredEBSVolumeID:
        default: Volume ID of Systemstate backup EBS volume restored from AWS Backup.
      WindowsAmiId:
        default: Bastion host operation system version
      DomainControllerAMI:
        default: Domain controller backup AMI obtained from AWS Backup. 
      KeyPair:
        default: Key pair name
      VPCCidrBlock:
        default: VPC CIDR for the new VPC to be created
      Subnet1AZ:
        default: Specify the availablility Zone for Subnet 1
      Subnet2AZ:
        default: Specify the availablility Zone for Subnet 2
      PrivateSubnet1:
        default: Enter a CIDR for private Subnet 1
      PrivateSubnet2:
        default: Enter a CIDR for private Subnet 2
      PublicSubnet1Cidr:
        default: Enter a CIDR for public Subnet 1
      PublicSubnet2Cidr:
        default: Enter a CIDR for public Subnet 1

Parameters:
  RestoredEBSVolumeID:
    Description: Volume ID of the restored volume containing Active Directory system state backup [E.g. vol-06e1f951aa98dd7c8]. This volume must be in the availability zone specified in Subnet1AZ (Subnet1)
    Type: String

  WindowsAmiId:
    Default: /aws/service/ami-windows-latest/Windows_Server-2019-English-Full-Base
    AllowedValues:
      - /aws/service/ami-windows-latest/Windows_Server-2016-English-Full-Base
      - /aws/service/ami-windows-latest/Windows_Server-2019-English-Full-Base
      - /aws/service/ami-windows-latest/Windows_Server-2022-English-Full-Base
    Description: Base AMI for the Bastion Host
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>

  DomainControllerAMI:
    Description: Backup AMI of the domain controller instance obtained from AWS Backup.
    Type: AWS::EC2::Image::Id

  InstanceType:
    Type: String
    Default: m5.large
    AllowedValues:
      - t3.medium
      - t3.large
      - m5.large
      - m5.xlarge
      - m5.2xlarge
      - m5.4xlarge
    Description: Amazon EC2 instance type for the restored domain controller instance

  RestoredDcNameTag:
    Description: EC2 name tag for the restored domain controller
    Type: String
    Default: RestoredDomainController

  VPCCidrBlock:
    Type: String
    Default: 10.10.0.0/16
    AllowedPattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(1[6-9]|2[0-8]))$"    
    Description: VPC CIDR Block (eg 10.0.0.0/16)

  Subnet1AZ:
    Description: Availability Zone (AZ) of Subnet1. The restored EBS Volume must be in this AZ.
    Type: AWS::EC2::AvailabilityZone::Name

  Subnet2AZ:
    Description: Availability Zone (AZ) of Subnet2
    Type: AWS::EC2::AvailabilityZone::Name

  PublicSubnet1Cidr:
    Type: String
    Default: 10.10.0.0/24
    AllowedPattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(1[6-9]|2[0-8]))$"    
    Description: VPC CIDR Block for the Public Subnet (eg 10.0.0.0/24)    
  PublicSubnet2Cidr:
    Type: String
    Default: 10.10.1.0/24
    AllowedPattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(1[6-9]|2[0-8]))$"    
    Description: VPC CIDR Block for the Public Subnet (eg 10.0.0.0/24)  

  PrivateSubnet1:
    Type: String
    Default: 10.10.5.0/24
    AllowedPattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(1[6-9]|2[0-8]))$"    
    Description: VPC CIDR Block for the Public Subnet (eg 10.0.0.0/24) 
       
  PrivateSubnet2:
    Type: String
    Default: 10.10.15.0/24
    AllowedPattern: "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/(1[6-9]|2[0-8]))$"    
    Description: VPC CIDR Block for the Public Subnet (eg 10.0.0.0/24) 
 
  KeyPair:
    Description: Public/private key pairs to securely connect to your instance after it launches.
    Type: AWS::EC2::KeyPair::KeyName

Resources:
  ApplicationVPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 
        Ref: VPCCidrBlock
      EnableDnsSupport: "true"
      EnableDnsHostnames: "true"
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ApplicationVPC
      CidrBlock: 
        Ref: PublicSubnet1Cidr
      AvailabilityZone: !Ref Subnet1AZ
      MapPublicIpOnLaunch: true
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ApplicationVPC
      CidrBlock: 
        Ref: PublicSubnet2Cidr
      AvailabilityZone: !Ref Subnet2AZ
      MapPublicIpOnLaunch: true
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PrivateSub1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ApplicationVPC
      CidrBlock:
        Ref: PrivateSubnet1
      AvailabilityZone: !Ref Subnet1AZ
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PrivateSub2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId:
        Ref: ApplicationVPC
      CidrBlock:
        Ref: PrivateSubnet2
      AvailabilityZone: !Ref Subnet2AZ
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  AttachInternetGateway:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId:
        Ref: ApplicationVPC
      InternetGatewayId:
        Ref: InternetGateway
  PrivateRouteTableSubnet1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId:
        Ref: ApplicationVPC
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PrivateRouteTableSubnet2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId:
        Ref: ApplicationVPC
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId:
        Ref: ApplicationVPC
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  RouteInternetGateway:
    DependsOn: InternetGateway
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: "0.0.0.0/0"
      GatewayId: !Ref InternetGateway
  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: PublicSubnet1
      RouteTableId:
        Ref: PublicRouteTable
  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: PublicSubnet2
      RouteTableId:
        Ref: PublicRouteTable
  PrivateSub1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: PrivateSub1
      RouteTableId:
        Ref: PrivateRouteTableSubnet1

  PrivateSub2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId:
        Ref: PrivateSub2
      RouteTableId:
        Ref: PrivateRouteTableSubnet2

  NATGatewayEIPSubnet1:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  NATGatewaySubnet1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIPSubnet1.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  RouteNATGatewaySubnet1:
    DependsOn: NATGatewaySubnet1
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableSubnet1
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref NATGatewaySubnet1
  NATGatewayEIPSubnet2:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  NATGatewaySubnet2:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NATGatewayEIPSubnet2.AllocationId
      SubnetId: !Ref PublicSubnet2
      Tags:
        - Key: CloudformationStackName
          Value: !Sub ${AWS::StackName}

  RouteNATGatewaySubnet2:
    DependsOn: NATGatewaySubnet2
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTableSubnet2
      DestinationCidrBlock: "0.0.0.0/0"
      NatGatewayId: !Ref NATGatewaySubnet2

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
        - !Sub arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy
      Path: /
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action: cloudformation:SignalResource
                Effect: Allow
                Resource: !Sub arn:${AWS::Partition}:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*
              - Action: ssm:SendCommand
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:*:document/AWS-RunRemoteScript
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:*:document/AWS-RunPowerShellScript
              - Action: ssm:SendCommand
                Condition:
                    StringEquals: 
                      'ssm:ResourceTag/aws:cloudformation:stack-name': !Ref AWS::StackName
                Effect: Allow
                Resource: !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*
              - Action: ssm:StartAutomationExecution
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:automation-definition/${AdForestRestoreAuto}:$DEFAULT
              - Action: ec2:AuthorizeSecurityGroupEgress
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:security-group/*
              - Action:
                  - ec2:DescribeInstances
                  - ec2:DescribeSecurityGroups
                  - ssm:DescribeInstanceInformation
                  - ssm:GetAutomationExecution
                  - ssm:ListCommands
                  - ssm:ListCommandInvocations
                Effect: Allow
                Resource: "*"
          PolicyName: Inline-Policy
      RoleName: !Sub Instance-Role-${AWS::StackName}
      Tags:
        - Key: StackName
          Value:
            Ref: AWS::StackName
  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub Instance-Role-${AWS::StackName}
      Path: /
      Roles:
        - Ref: InstanceRole

  DomainControllersSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Domain Controllers Security Group
      VpcId: !Ref ApplicationVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          Description: DNS
          FromPort: 53
          ToPort: 53
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: DNS
          FromPort: 53
          ToPort: 53
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: Kerberos
          FromPort: 88
          ToPort: 88
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: Kerberos
          FromPort: 88
          ToPort: 88
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: Windows Time
          FromPort: 123
          ToPort: 123
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: RPC Port
          FromPort: 135
          ToPort: 135
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: Netlogon
          FromPort: 138
          ToPort: 138
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: LDAP
          FromPort: 389
          ToPort: 389
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: LDAP
          FromPort: 389
          ToPort: 389
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: SMB
          FromPort: 445
          ToPort: 445
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: SMB
          FromPort: 445
          ToPort: 445
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: Kerberos Set & Change Password
          FromPort: 464
          ToPort: 464
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: Kerberos Set & Change Password
          FromPort: 464
          ToPort: 464
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: LDAP over SSL
          FromPort: 636
          ToPort: 636
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: LDAP Global Catalog
          FromPort: 3268
          ToPort: 3268
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: LDAP Global Catalog over SSL
          FromPort: 3269
          ToPort: 3269
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: RDP
          FromPort: 3389
          ToPort: 3389
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: WinRM
          FromPort: 5985
          ToPort: 5985
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: SOAP ADWS
          FromPort: 9389
          ToPort: 9389
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: tcp
          Description: Random RPC
          FromPort: 49152
          ToPort: 65535
          SourceSecurityGroupId: !Ref DomainMembersSG
        - IpProtocol: udp
          Description: Random RPC
          FromPort: 49152
          ToPort: 65535
          SourceSecurityGroupId: !Ref DomainMembersSG
      Tags:
        - Key: Name
          Value: DomainControllersSecurityGroup

  DomainMembersSG:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Domain Members
      VpcId: !Ref ApplicationVPC
      Tags:
        - Key: Name
          Value: DomainMembersSecurityGroup
  DomainMembersIngressRDP:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: RDP
      GroupId: !Ref DomainMembersSG
      IpProtocol: tcp
      FromPort: 3389
      ToPort: 3389
      SourceSecurityGroupId: !Ref DomainMembersSG
      
  RestoredDC:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref DomainControllerAMI
      IamInstanceProfile: !Ref InstanceProfile
      InstanceType: !Ref InstanceType
      SubnetId: !Ref PrivateSub1
      Tags:
        - Key: Name
          Value: !Ref RestoredDcNameTag
      SecurityGroupIds:
        - !Ref DomainControllersSG
      KeyName: !Ref KeyPair

  MountPoint:
    Type: AWS::EC2::VolumeAttachment
    Properties:
       InstanceId: !Ref RestoredDC
       VolumeId: !Ref RestoredEBSVolumeID
       Device: xvdbw

  BastionHost:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref WindowsAmiId
      IamInstanceProfile: !Ref InstanceProfile
      InstanceType: t3.medium
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: BastionHost
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: 30
            VolumeType: gp3
            DeleteOnTermination: true
      SecurityGroupIds:
        - !Ref DomainMembersSG
      KeyName: !Ref KeyPair

  AdForestRestoreAuto:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Automation
      Content:
        schemaVersion: "0.3"
        description: Restores Active Directory data from the specified backup volume
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          RestoredDCInstanceId:
            description: InstanceID of the restored domain controller
            type: String
          AutomationAssumeRole:
            default: ""
            description: "(Optional) The ARN of the role that allows Automation to perform the actions on your behalf."
            type: "String" 

        mainSteps:
          - name: getRestoredDC
            action: aws:executeAwsApi
            inputs:
              Service: ec2
              Api: DescribeInstances
              Filters:
                - Name: tag:Name
                  Values:
                    - !Ref RestoredDcNameTag
                - Name: instance-state-name
                  Values:
                    - running
            outputs:
              - Name: InstanceId
                Selector: $.Reservations[0].Instances[0].InstanceId
                Type: String
            nextStep: assertSSMAgentOnline
          - name: assertSSMAgentOnline
            action: aws:waitForAwsResourceProperty
            maxAttempts: 3
            timeoutSeconds: 500
            onFailure: Abort
            inputs:
              Service: ssm
              Api: DescribeInstanceInformation
              InstanceInformationFilterList:
              - key: InstanceIds
                valueSet:
                - "{{getRestoredDC.InstanceId}}"
              PropertySelector: "$.InstanceInformationList[0].PingStatus"
              DesiredValues:
              - Online
            isCritical: 'true'
            nextStep: SleepWait

          - name: SleepWait
            action: aws:sleep
            inputs:
              Duration: PT1M
            nextStep: setDNS

          - name: setDNS
            action: aws:runCommand
            maxAttempts: 3
            onFailure: Continue
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{getRestoredDC.InstanceId}}"
              Parameters:
                commands: |-
                    Write-Output "Setting variables for the Write-Log function"

                    $DestinationDriveFolder="C:\Windows\temp"
                    $LogFile = $DestinationDriveFolder + "\AD-Disaster-Recovery-Log.txt"

                    function Write-Log{
                        PARAM
                        (
                            [Parameter(Mandatory = $true)] [string] $Message
                            ,[ValidateSet("Green", "Yellow", "Red")] [string] $Color
                        )
                        $Datestamp = [datetime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
                        $CompleteMessage = "$Datestamp $Message"
                        if($Color)
                            {
                            Write-Host $CompleteMessage -ForegroundColor $Color
                            }
                        else
                            {
                            Write-Host $CompleteMessage
                            }
                        Write-Output $CompleteMessage | out-file -encoding ASCII $LogFile -Append
                    }

                    Write-Output "Setting DNS to AmazonProvidedDNS to resolve SSM endpoint when in DSRM mode"
                    try {
                        Get-NetAdapter | Select-Object InterfaceAlias , InterfaceIndex
                        $IntIndex = Get-NetAdapter | where-Object {$_.ifDesc -notlike "*TAP*" -and $_.status -eq "Up"} | foreach InterfaceIndex | Select-Object -First 1
                        Set-DnsClientServerAddress -InterfaceIndex $IntIndex -ResetServerAddresses
                        Set-DnsClientServerAddress -InterfaceIndex $IntIndex -ServerAddresses ("169.254.169.253")
                        write-log "Successfully set DNS to AmazonProvidedDNS"
                    } catch [System.Exception] {
                        write-log "unable set DNS to AmazonProvidedDNS"
                        Write-Log ($Error[0].Exception)
                    }
            nextStep: SetDSRMmode

          - name: SetDSRMmode
            action: aws:runCommand
            maxAttempts: 3
            onFailure: Continue
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{getRestoredDC.InstanceId}}"
              Parameters:
                commands: |-
                    Write-Output "Setting variables for the Write-Log function"

                    $DestinationDriveFolder="C:\Windows\temp"
                    $LogFile = $DestinationDriveFolder + "\AD-Disaster-Recovery-Log.txt"

                    function Write-Log{
                        PARAM
                        (
                            [Parameter(Mandatory = $true)] [string] $Message
                            ,[ValidateSet("Green", "Yellow", "Red")] [string] $Color
                        )
                        $Datestamp = [datetime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
                        $CompleteMessage = "$Datestamp $Message"
                        if($Color)
                            {
                            Write-Host $CompleteMessage -ForegroundColor $Color
                            }
                        else
                            {
                            Write-Host $CompleteMessage
                            }
                        Write-Output $CompleteMessage | out-file -encoding ASCII $LogFile -Append
                    }

                     if (bcdedit | findstr "DsRepair") {                        
                         Write-Output "Server is in Directory Services Restore Mode...System State restore will proceed"
                        }
                      
                      Else {                      
                      Write-Log "Setting the instance in Directory Service Restore Mode"
                       try {
                          Install-WindowsFeature Windows-Server-Backup
                          Write-Output "Windows Server Backup tool successfully installed"
                        } Catch [System.Exception] {
                          write-Output "Unable to install Windows Server Backup"
                          Write-Log ($Error[0].Exception)
                        }

                        Write-Output "Restarting the instance in Directory Services Restore Mode"

                        try {
                          cmd.exe /c "bcdedit /set {default} safeboot dsrepair"
                          exit 3010
                        } Catch [System.Exception] {
                          write-Output "Unable to restart the instance in Directory Services Restore Mode"
                          Write-Log ($Error[0].Exception)
                        }
                    }
            isCritical: 'true'
            nextStep: SleepWait1M

          - name: SleepWait1M
            action: aws:sleep
            inputs:
              Duration: PT1M
            nextStep: assertSSMAgentOnlineAgain

          - name: assertSSMAgentOnlineAgain
            action: aws:waitForAwsResourceProperty
            maxAttempts: 3
            timeoutSeconds: 500
            onFailure: Abort
            inputs:
              Service: ssm
              Api: DescribeInstanceInformation
              InstanceInformationFilterList:
              - key: InstanceIds
                valueSet:
                - "{{getRestoredDC.InstanceId}}"
              PropertySelector: "$.InstanceInformationList[0].PingStatus"
              DesiredValues:
              - Online
            isCritical: 'true'
            nextStep: SystemStateRestore

          - name: SystemStateRestore
            action: aws:runCommand
            maxAttempts: 3
            onFailure: Continue
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{getRestoredDC.InstanceId}}"
              Parameters:
                commands: |-
                    Write-Output "Setting variables for the Write-Log function"

                    $DestinationDriveFolder="C:\Windows\temp"
                    $LogFile = $DestinationDriveFolder + "\AD-Disaster-Recovery-Log.txt"

                    function Write-Log{
                        PARAM
                        (
                            [Parameter(Mandatory = $true)] [string] $Message
                            ,[ValidateSet("Green", "Yellow", "Red")] [string] $Color
                        )
                        $Datestamp = [datetime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
                        $CompleteMessage = "$Datestamp $Message"
                        if($Color)
                            {
                            Write-Host $CompleteMessage -ForegroundColor $Color
                            }
                        else
                            {
                            Write-Host $CompleteMessage
                            }
                        Write-Output $CompleteMessage | out-file -encoding ASCII $LogFile -Append
                    }

                    if (!(Test-Path $LogFile)){
                        New-Item -path $LogFile
                        Write-Log "New Log File Created"
                    }

                    Write-Log "Starting the SystemState restore process"

                    $backupDisk = Get-Disk | Where-Object {$_.IsBoot -eq $False} | Sort-Object -Property Number | Select-Object -Last 1
                    if ($backupDisk.IsOffline -eq $True) {
                        try {
                            Set-Disk $backupDisk.Number -IsOffline $False -ErrorAction Stop
                            Set-Disk $backupDisk.Number -IsReadOnly $False -ErrorAction Stop
                        } catch {
                            Write-Log ("Failed to bring backup volume online")
                            Write-Log ($Error[0].Exception)
                            exit 1
                        }
                    }
                    $backupVolume = ($backupDisk | Get-Partition).DriveLetter + ":"
                     try {
                    $backupVersions = wbadmin get versions -backupTarget:$backupVolume | findstr "Version identifier"
                      } Catch [System.Exception] {
                       write-Log "Unable to get system state backup versions"
                       Write-Log ($Error[0].Exception)
                       exit 1
                     }  
                  
                    if ($backupVersions.Count -lt 1) {
                        Write-Log "No system state backup found. Make sure the specified volume contains the system state backup from Active Directory. Exiting..."
                        exit 1
                      }

                    elseif ($backupVersions.Count -gt 1) {
                        $latestBackup = $backupVersions[-1]
                        $BackupID = $latestBackup.Substring(20)
                        Write-Log "Multiple backups found. Will restore from the latest backup ID: $BackupID"
                      }
                      
                    elseif ($backupVersions.Count -eq 1) {
                        $latestBackup = $backupVersions
                        $BackupID = $latestBackup.Substring(20)
                        Write-Log "Single backup found. Backup ID is $BackupID"
                      }
                      
                    Write-Log "Starting System State Restore operation using backup version $BackupID"
                    try {
                      cmd.exe /c "bcdedit /deletevalue {default} safeboot"
                      wbadmin start systemstaterecovery -version:$BackupID -backupTarget:$backupVolume -quiet -autoReboot
                      } Catch [System.Exception] {
                      write-Log "Unable to perform System State Restore"
                      Write-Log ($Error[0].Exception)
                    }  
            isCritical: 'true'
            nextStep: reassertSSMAgentOnline

          - name: reassertSSMAgentOnline
            action: aws:waitForAwsResourceProperty
            maxAttempts: 3
            timeoutSeconds: 500
            onFailure: Abort
            inputs:
              Service: ssm
              Api: DescribeInstanceInformation
              InstanceInformationFilterList:
              - key: InstanceIds
                valueSet:
                - "{{getRestoredDC.InstanceId}}"
              PropertySelector: "$.InstanceInformationList[0].PingStatus"
              DesiredValues:
              - Online
            isCritical: 'true'
            nextStep: SleepWait5M

          - name: SleepWait5M
            action: aws:sleep
            inputs:
              Duration: PT5M
            nextStep: CleanUpADAfterRestore

          - name: CleanUpADAfterRestore
            action: aws:runCommand
            maxAttempts: 3
            onFailure: Continue
            inputs:
              DocumentName: AWS-RunPowerShellScript
              InstanceIds:
                - "{{getRestoredDC.InstanceId}}"
              Parameters:
                commands: |-               
                  Write-Output "Setting variables for the Write-Log function"
                                      
                  $DestinationDriveFolder="C:\Windows\temp"
                  $LogFile = $DestinationDriveFolder + "\AD-Disaster-Recovery-Log.txt"

                  function Write-Log{
                      PARAM
                      (
                          [Parameter(Mandatory = $true)] [string] $Message
                      )
                      $Datestamp = [datetime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
                      $CompleteMessage = "$Datestamp $Message"
                      Write-Output $CompleteMessage
                      Write-Output $CompleteMessage | out-file -encoding ASCII $LogFile -Append
                  }

                  if (!(Test-Path $LogFile)){
                      New-Item -path $LogFile
                      Write-Log "New Log File Created"
                  }

                      Write-Log "Setting DNS as authoritative for the domain"                                                 
                      try {
                          Get-NetAdapter | Select-Object InterfaceAlias , InterfaceIndex
                          $IntIndex = Get-NetAdapter | where-Object {$_.ifDesc -notlike "TAP*"} | foreach InterfaceIndex | Select-Object -First 1
                          Set-DnsClientServerAddress -InterfaceIndex $IntIndex -ResetServerAddresses
                          Set-DnsClientServerAddress -InterfaceIndex $IntIndex -ServerAddresses ("127.0.0.1")
                          write-log "Successfully set DNS as authorative for the domain"
                      } catch [System.Exception] {
                          write-log "unable set current server as authoritaive DNS server for the domain"
                          Write-Log ($Error[0].Exception)
                      }
                      
                      Write-Log "Setting DNS forwarder to AmazonProvidedDNS"
                      try {
                          Set-DnsServerForwarder -IPAddress "169.254.169.253" -PassThru
                          write-log "Successfully set DNS forwarder to Amazon Provided DNS"      
                      }  Catch [System.Exception] {
                          write-log "Unable to restart one or more Active Directory Services"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Setting SYSVOL to ready"
                      $SysVolRegPath = 'HKLM:\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters'
                      $sysvolstatus = (Get-ItemProperty -Path $SysVolRegPath).sysvolready
                      if ($sysvolstatus -ne 1){
                        try {
                          Set-ItemProperty -Path $SysVolRegPath -Name "SysvolReady" -Value 1
                          write-log "SYSVOL succesfully set to ready"
                          Start-Sleep -Seconds 5
                        }  Catch [System.Exception] {
                          write-log "Could not set sysvol to ready"
                          Write-Log ($Error[0].Exception)
                          exit 1
                        }
                      }

                      Write-Log "Restarting Active Directory Domain Services"
                      try {
                          Restart-Service NTDS -Force
                          write-log "Successfully restarted Active Directory Services" 
                      }  Catch [System.Exception] {
                          write-log "Unable to restart one or more Active Directory Domain Services"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Removing retired DCs' Domain names from DNS"
                      try {
                          $Domain = (Get-ADDomain).Forest
                          $LocalIp = ((ipconfig | findstr [0-9].\.)[0]).Split()[-1]
                          $IPsToRemove = ((Resolve-DnsName $Domain) | where-Object {$_.IpAddress -ne $LocalIp}).ipaddress
                          $dnszones = Get-DnsServerZone | Select-Object ZoneName

                          $RestoredDomainController = [System.Net.Dns]::GetHostByName($env:COMPUTERNAME).HostName
                          $RestiredDCs = Get-ADDomainController -filter * | where-Object {$_.HostName -ne $RestoredDomainController}
                          $RestiredDCNames = $RestiredDCs.Name
                          Foreach ($RestiredDCName in $RestiredDCNames){
                              ForEach ($zone in $dnszones){
                                      $ZoneName = $Zone.ZoneName
                                      Get-DnsServerResourceRecord -ZoneName $zonename | `
                                      where-Object {$_.RecordData.nameserver -like "*$($RestiredDCName)*" `
                                      -OR $_.RecordData.DomainName -like "*$($RestiredDCName)*" `
                                      -OR $_.RecordData.HostNameAlias -like "*$($RestiredDCName)*" `
                                      -OR $_.RecordData.PrimaryServer -like "*$($RestiredDCName)*" `
                                      -OR $_.RecordData.PtrDomainName -like "*$($RestiredDCName)*" } `
                                      | Remove-DnsServerResourceRecord -ZoneName $zonename -force
                              }
                          }
                          Write-Log "Successfully deleted DNS names of retired Domain Controllers"
                      } Catch [System.Exception] {
                          write-log "Failed to delete some retired DC records from DNS"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Removing retired DC IP addresses from DNS"                        
                      try {
                          $LocalIp = ((ipconfig | findstr [0-9].\.)[0]).Split()[-1]
                          $IPsToRemove = ((Resolve-DnsName $Domain) | where-Object {$_.IpAddress -ne $LocalIp}).ipaddress
                          $dnszones = Get-DnsServerZone | Select-Object ZoneName
                          ForEach ($IPsToRemove in $IPsToRemove){
                              ForEach ($zone in $dnszones){
                                  $ZoneName = $Zone.ZoneName
                                  Get-DnsServerResourceRecord -ZoneName $zonename | `
                                  where-Object {$_.RecordData.IPv4Address -eq $IPsToRemove } | Remove-DnsServerResourceRecord -ZoneName $zonename -Force
                              }
                          }
                          Write-Log "Successfully deleted IP addresses of the retired Domain Controllers"         
                      }   Catch [System.Exception] {
                          write-log "Failed to delete some or all of the IP addresses of retired domain controllers from DNS"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Restarting Netlogon service"
                      try {
                          Restart-Service Netlogon -errorAction SilentlyContinue 
                          write-log "Successfully restarted the Netlogon service"  
                      }  Catch [System.Exception] {
                          write-log "Could not restart the Netlogon service"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Seizing the FSMO roles"
                      try {
                          Get-ADDomainController -Filter * | Select-Object hostname
                          $ServerName = hostname
                          Move-ADDirectoryServerOperationMasterRole -Identity $ServerName DomainNamingMaster, InfrastructureMaster, RIDMaster, PDCEmulator, SchemaMaster -Force -Confirm:$false
                          netdom query fsmo  
                          write-log "Successfully seized all FSMO roles"       
                      }  Catch [System.Exception] {
                          write-log "unable to seize some or all FSMO roles"
                          Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Configure intitial msDFSR settings"
                      try {
                          $RestoredDC = $env:COMPUTERNAME
                          $DN = (Get-ADDomainController -Identity $RestoredDC).ComputerObjectDN
                          $SysvolSettings = Get-ADObject "CN=SYSVOL Subscription,CN=Domain System Volume,CN=DFSR-LocalSettings,$DN" -Properties msDFSR-Enabled,msDFSR-options

                          $SysvolSettings.'msDFSR-Enabled' = $False
                          $SysvolSettings.'msDFSR-options' = 1
                          Set-ADObject -Instance $SysvolSettings
                          write-log "Successfully set msDFSR-Enabled and msDFSR-options"  
                      }   Catch [System.Exception] {
                          write-log "Unable to configure intitial msDFSR settings"
                          Write-Log ($Error[0].Exception)
                      } 

                      Write-Log "Synchronizing AD and Restarting DFSR"
                      try {
                          #repadmin /syncall /APed
                          Restart-Service -Name dfsr
                          write-log "Successfully restarted the DFSR service"                    
                      } Catch [System.Exception] {
                          write-log "Unable to restart DFSR service"
                          Write-Log ($Error[0].Exception)
                      } 

                      Write-Log "Configure final msDFSR settings"
                      try {
                          $SysvolSettings.'msDFSR-Enabled' = $True            
                          Set-ADObject -Instance $SysvolSettings
                          write-log "Successfully set msDFSR-Enabled back to true"
                      } Catch [System.Exception] {
                          write-log "unable to make sysvol authoritative"
                          Write-Log ($Error[0].Exception)
                      } 

                      # Write-Log "Synchronizing AD"
                      # try {
                      #     #repadmin /syncall /APed
                      # }  Catch [System.Exception] {
                      #     write-log "Failed to sync. This can be ignored as there are no other domain controllers in the isolated VPC at the moment"
                      # }

                      Write-Log "Attempting to raise the RID pool by 100,000"
                      try {
                          $RidIncrement = 100000
                          $domain = Get-ADDomain
                          $RidPool = Get-ADObject "CN=RID Manager$,CN=System,$($domain.DistinguishedName)" -properties rIDAvailablePool | Select-Object -ExpandProperty rIDAvailablePool
                          $NewRidPool = $RidPool + $RidIncrement
                          Set-ADObject "CN=RID Manager$,CN=System,$($domain.DistinguishedName)" -replace @{ridavailablePool= $NewRidPool}
                          Write-Log "Successfully raised the RID pool from $RidPool to $NewRidPool"
                          } catch [System.Exception] {
                            Write-Log "Unable to raise RID pool"
                            Write-Log ($Error[0].Exception)
                      }

                      Write-Log "Configuring the the domain controller to synchronize time from the Amazon Time Service"
                      try {
                          w32tm /config /manualpeerlist:169.254.169.123 /syncfromflags:manual /reliable:yes /update
                          write-log "Successfully configured the time service to sync with the Amazon Time Service"
                      } Catch [System.Exception] {
                          write-log "Unable configure the Windows Time service"
                          Write-Log ($Error[0].Exception)
                      }

                      write-log "Performing Metadata cleanup..."
                      $Domain = Get-ADDomain
                      $RestoredDomainController = $env:COMPUTERNAME
                      $Sites = Get-ADReplicationSite -Filter "*"
                      $RetiredDomainControllers = Get-ADDomainController -filter * | where-Object {$_.Name -notlike $RestoredDomainController}
                      write-log "The following domain controllers will be removed from the AD database: $RetiredDomainControllers"
                      Foreach ($Site in $Sites){
                          Foreach ( $RetiredDomainController in  $RetiredDomainControllers){
                              try {
                                  write-log "checking for $RetiredDomainController in site $Site ..."
                                  $CheckDCSite = Get-ADObject -Identity "cn=$($RetiredDomainController),cn=servers,$($Site.DistinguishedName)" -Partition "CN=Configuration,$($Domain.distinguishedName)" -Properties * -ErrorAction SilentlyContinue
                              }   catch [System.Exception] {
                                  write-log "Cannot find ADObject $RetiredDomainController in site $Site"            
                              }

                              If ($CheckDCSite) {
                                try {     
                                          Write-Log "$( $RetiredDomainController) found in $($Site)...starting metadata cleanup"
                                          Start-process -FilePath ntdsutil -argumentList """metadata cleanup"" ""remove selected server cn=$($RetiredDomainController),cn=servers,$($Site.DistinguishedName)"" q q" -wait -nonewwindow
                                          write-log "AD Metadatacleanup completed for $( $RetiredDomainController)"
                                    }   Catch [System.Exception] {
                                        write-log "Unable to perform metadata cleanup for $( $RetiredDomainController)"
                                        Write-Log ($Error[0].Exception)
                                }
                              }
                          }
                      }  
            isCritical: 'true'

  AutomationExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: ssm.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Action: ssm:StartAutomationExecution
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:automation-definition/${AdForestRestoreAuto}:$DEFAULT
              - Action:
                  - ec2:DescribeInstances
                  - ec2:DescribeSecurityGroups
                  - ssm:DescribeInstanceInformation
                  - ssm:GetAutomationExecution
                  - ssm:ListCommands
                  - ssm:ListCommandInvocations
                Effect: Allow
                Resource: "*"
              - Action: ssm:SendCommand
                Effect: Allow
                Resource:
                  - !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:*:document/AWS-RunPowerShellScript
              - Action: ssm:SendCommand
                Condition:
                    StringEquals: 
                      'ssm:ResourceTag/aws:cloudformation:stack-name': !Ref AWS::StackName
                Effect: Allow
                Resource: !Sub arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*
          PolicyName: Inline-Policy
  TestAutomationAssociation:
    DependsOn: MountPoint
    Type: AWS::SSM::Association
    Properties:
      Name: !Ref AdForestRestoreAuto
      AutomationTargetParameterName: RestoredDCInstanceId
      Targets:
        - Key: tag:Name
          Values:
            - !Ref RestoredDcNameTag
      Parameters:
        AutomationAssumeRole:
          - !GetAtt 'AutomationExecutionRole.Arn'

Outputs:
  BastionPublicIp:
    Value: !GetAtt BastionHost.PublicIp
    Description: The public IP of the bastion host instance.
  RestoredDCPrivateIP:
    Value: !GetAtt RestoredDC.PrivateIp
    Description: The private IP address of the restored domain controller.